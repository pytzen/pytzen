<link rel="stylesheet" href="https://pablo.haus/styles.css">

`pytzen` provides a minimal structured approach to data science pipelines, encompassing modularity, automation, and documentation in one package.

![pytzen.github.io](https://pablo.haus/concepts/pytzen-github-io.png)

[pablo.haus](https://pablo.haus): author's landpage

## Inspiration
Inspired by Ikigai, Kaizen, Pomodoro Technique, Hara Hachi Bu, Shoshin, Wabi-sabi.

### Minimalistic Principles
**Simplicity**: This is the core of minimalism. Whether it's design, writing, or lifestyle, the focus is on simplicity. It's about removing the unnecessary and focusing on what truly matters.

**Clarity**: Everything in minimalism should be easily understood. In design, this often means using straightforward graphics and concise text.

**Functionality**: Every element should have a purpose. If it doesn't add value or function, it's often removed in a minimalist approach.

**Limitation**: This could mean limiting colors in a design, words in writing, or possessions in a minimalist lifestyle.

**Harmony**: Even though there might be fewer elements, they should work harmoniously together.

**Intentionality**: Every choice made should be deliberate. Minimalism isn't about deprivation, but rather making intentional decisions.

### Python Minimalistic Code
- Objects names and type hints are documentation.
- Docstrings for classes and methods in all-in-one paragraph.
- Reduce classes and methods to its minimal functionality.

## Usage & Limitations Overview

### Disclaimer
This library is offered 'as-is' with **no official support, maintenance, or warranty**. Primarily, `pytzen` is an experimentation, which may not be apt for production settings. Users are encouraged to delve into the library but should note that the developers won't actively address arising issues.

### Usage Caution
`pytzen` is primarily intended for prototyping, such as in Proof-of-Concept (POC) or Minimum Viable Product (MVP) stages. We are not liable for issues arising from the library's usage in production environments. Before considering any wider implementation, users should extensively test and vet the library in a safe, controlled environment.

## Documentation
In essence, the code provides a framework for creating classes with a standard logging mechanism, a way to generate documentation for them, and a shared configuration and data attributes manager.

### `pytzen` basic usage

There are 4 requirements to use the pattern:
1. `pip install pytzen`
2. Create a `config.json` file in the current directory.
3. Use the `@dataclass` decorator.
4. Inherit from `ProtoType`.


```python
# Lets make it run in a Jupyter Notebook.
import sys
sys.path.append('/home/pytzen/lab/pytzen.github.io/test')

# Required imports
import pytzen as zen
from dataclasses import dataclass

# You MUST create a 'config.json' file in the current directory.
# It will contain your configuration variables.
# These variables will be explained later in this tutorial.
# Lets see an example of JSON configuration file.
try:
    with open('config.json', 'r') as f:
        print("Contents of 'config.json':\n")
        print(f.read())
except FileNotFoundError:
    print("Error: 'config.json' file not found in the current directory.",
          "You MUST create a 'config.json' file in the current directory.",
          sep='\n')
```

    Contents of 'config.json':
    
    {
        "str_input": "some_input",
        "int_input": 10,
        "list_input": [
            "item1",
            "item2"
        ],
        "dict_input": {
            "key1": "value1",
            "key2": "value2"
        }
    }



```python
# You MUST use the '@dataclass' decorator and inherit from 'ProtoType'.
@dataclass
class DerivedClass(zen.ProtoType):
    # This is the '@dataclass' way to define a class attribute.
    number: int = 137

    def do(self):
        print("I am using a '@dataclass' attribute in the 'ProtoType' way.")
        print(f'I am calling it (self.data.number): {self.data.number}')

derived = DerivedClass()
derived.do()
```

    I am using a '@dataclass' attribute in the 'ProtoType' way.
    I am calling it (self.data.number): 137



```python
# Take a look at the autogenerated docstring helper made by '@dataclass'.
# Also, notice the elements brought by 'ProtoType'.
help(derived)
```

    Help on DerivedClass in module __main__ object:
    
    class DerivedClass(pytzen.ProtoType)
     |  DerivedClass(*args, **kwargs) -> object
     |
     |  DerivedClass(*args, **kwargs) -> object
     |
     |  Method resolution order:
     |      DerivedClass
     |      pytzen.ProtoType
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __eq__(self, other)
     |      Return self==value.
     |
     |  __init__(self, number: int = 137) -> None
     |      Initializes the class. It is called when the derived class
     |      is instantiated by the controled behavior of 'MetaType'.
     |
     |      Returns:
     |          None
     |
     |  __repr__(self)
     |      Return repr(self).
     |
     |  close() -> None from builtins.type
     |      Closes the classes and stores the pipeline information. It
     |      must be called after the last derived class is used.
     |
     |      Returns:
     |          None
     |
     |  do(self)
     |
     |  log(message, stdout=True, write=True) -> None from builtins.type
     |      Adds a message to the log attribute. The message is stored
     |      with the current timestamp.
     |
     |      Args:
     |          message: Message to be stored.
     |          stdout: If True, the message is printed.
     |          write: If True, the message is stored.
     |
     |      Returns:
     |          None
     |
     |  store(name, value) -> None from builtins.type
     |      Adds a value to the store attribute.
     |
     |      Args:
     |          name: Name of the value.
     |          value: Value to be stored.
     |
     |      Returns:
     |          None
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __annotations__ = {'number': <class 'int'>}
     |
     |  __dataclass_fields__ = {'number': Field(name='number',type=<class 'int...
     |
     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...
     |
     |  __hash__ = None
     |
     |  __match_args__ = ('number',)
     |
     |  class_path = '__main__.DerivedClass'
     |
     |  number = 137
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from pytzen.ProtoType:
     |
     |  __setattr__(self, key, value) -> None
     |      Adds an attribute to the class. It is called when an
     |      attribute is added to the derived class.
     |
     |      Args:
     |          key: Attribute name.
     |          value: Attribute value.
     |
     |      Returns:
     |          None
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from pytzen.ProtoType:
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from pytzen.ProtoType:
     |
     |  config = <class 'pytzen.ConfigurationFile'>
     |
     |  data = SharedData(classes={'__main__.DerivedClass': {'a...o', 'log', '...
    



```python
# Lets set an attribute dynamically.
@dataclass
class DynamicAttribute(zen.ProtoType):
    # There is no '@dataclass' defined attribute.
    
    def set_dynamically(self):
        # Lets set the attribute on the fly.
        print("I am setting an attribute using 'self.n = 137'.")
        self.n = 137
    
    def get_data(self):
        print('I am retrieving the data from the object.')
        print(f'I am calling it (self.data.number): {self.data.n}\n')
        try:
            print(self.n)
        except AttributeError as e:
            print(f"I cannot call 'self.number' directly.\n{e}.")

dynamic = DynamicAttribute()
dynamic.set_dynamically()
dynamic.get_data()
print("Conclusion: all attributes are stored in the 'data' object.",
      'There is no way to access it directly.',
      'But, why would you want to do that?',
      sep='\n')
```

    I am setting an attribute using 'self.n = 137'.
    I am retrieving the data from the object.
    I am calling it (self.data.number): 137
    
    I cannot call 'self.number' directly.
    'DynamicAttribute' object has no attribute 'n'.
    Conclusion: all attributes are stored in the 'data' object.
    There is no way to access it directly.
    But, why would you want to do that?



```python
@dataclass
class DataClassSample(zen.ProtoType):
    # This is the '@dataclass' way to define a class attribute.
    # The attribute must be declared in the initialization.
    m: int

@dataclass
class RetrieveSharedData(zen.ProtoType):

    def get_data(self):
        print("Objects in 'data' are shared among classes and instances:", 
              data_sample.data.m)
    
    def change_attribute(self):
        try:
            print('I am trying to reset an attribute directly.')
            self.m = 137
        except AttributeError as e:
            print(f"I cannot call 'self.m = 137'.\n{e}")
            print("The attribute also cannot be redefined using '@dataclass'.")

data_sample = DataClassSample(m=100)
get_data_sample = RetrieveSharedData()
get_data_sample.get_data()
get_data_sample.change_attribute()

```

    Objects in 'data' are shared among classes and instances: 100
    I am trying to reset an attribute directly.
    I cannot call 'self.m = 137'.
    Attribute 'm' already exists and cannot be changed.
    The attribute also cannot be redefined using '@dataclass'.



```python
# Nested classes cannot inherit from 'ProtoType'.
# They will be treated as regular shared attributes, but attributes from
# the nested class can be redifined.
@dataclass
class Nested:
    nested_attr:str
    pre_defined:str = 'I am a pre-defined attribute.'


@dataclass
class Container(zen.ProtoType):

    def print_nested(self):
        self.nested = Nested('I am a nested attribute.')
        print(self.data.nested.nested_attr)


@dataclass
class UseNested(zen.ProtoType):

    def print_nested(self):
        # The nested attribute is shared among classes and instances.
        print(self.data.nested.pre_defined)
        # Attributes from the nested class can be redefined.
        self.data.nested.pre_defined = 'Changed by UseNested.'
        print(self.data.nested.pre_defined)

container = Container()
container.print_nested()
use_nested = UseNested()
use_nested.print_nested()
```

    I am a nested attribute.
    I am a pre-defined attribute.
    Changed by UseNested.



```python
# Lets see how to use configuration variables.
@dataclass
class ConfigVariableSample(zen.ProtoType):

    def print_configuration_variable(self):
        print("\nConfiguration Variables:")
        print(f"String Input: {self.config.str_input}")
        print(f"Integer Input: {self.config.int_input}")
        print(f"List Input: {self.config.list_input}")
        print(f"Dictionary Input: {self.config.dict_input}")

config = ConfigVariableSample()
config.print_configuration_variable()
```

    
    Configuration Variables:
    String Input: some_input
    Integer Input: 10
    List Input: ['item1', 'item2']
    Dictionary Input: {'key1': 'value1', 'key2': 'value2'}



```python
# Lets see how to log some events in the pipeline.
@dataclass
class KeepLog(zen.ProtoType):
    
    some_message: str = 'I am a log message.'

    def log_it(self):
        self.log(self.data.some_message)
        self.log("If you don't want it to be printed, set 'stdout' to 'False'.",
                 stdout=False)
        self.log("If you don't want it to be exported, set 'write' to 'False'.",
                 write=False)

@dataclass
class KeepLog2(zen.ProtoType):
    
    some_message2: str = 'I am a log message again.'

    def log_it(self):
        self.log(self.data.some_message2)
        self.log('My pipeline did something.')

kl = KeepLog()
kl.log_it()
kl2 = KeepLog2()
kl2.log_it()
```

    2023-11-16 18:43:24.020779: I am a log message.
    2023-11-16 18:43:24.020947: If you don't want it to be exported, set 'write' to 'False'.
    2023-11-16 18:43:24.021039: I am a log message again.
    2023-11-16 18:43:24.021051: My pipeline did something.



```python
# Lets inspect the log object.
kl.data.log
```




    {'2023-11-16 18:43:24.020779': 'I am a log message.',
     '2023-11-16 18:43:24.020933': "If you don't want it to be printed, set 'stdout' to 'False'.",
     '2023-11-16 18:43:24.021039': 'I am a log message again.',
     '2023-11-16 18:43:24.021051': 'My pipeline did something.'}




```python
# Lets store some simple data from the pipeline.
@dataclass
class KeepResultsStored(zen.ProtoType):

    def store_results(self):
        self.store('some_results', {'result':3, 'diff':4})

@dataclass
class KeepResultsStored2(zen.ProtoType):

    def store_results(self):
        self.store('some_results2', {'result2':3, 'diff2':4})
    
krs = KeepResultsStored()
krs.store_results()
krs2 = KeepResultsStored2()
krs2.store_results()
krs2.data.store
```




    {'some_results': {'result': 3, 'diff': 4},
     'some_results2': {'result2': 3, 'diff2': 4}}




```python
# Lets see the status of our classes.
krs2.data.classes
```




    {'__main__.DerivedClass': {'attributes': {'number': 'int'},
      'methods': ['do', 'log', 'store', 'close']},
     '__main__.DynamicAttribute': {'attributes': {'n': 'int'},
      'methods': ['set_dynamically', 'get_data', 'log', 'store', 'close']},
     '__main__.DataClassSample': {'attributes': {'m': 'int'},
      'methods': ['log', 'store', 'close']},
     '__main__.RetrieveSharedData': {'attributes': {},
      'methods': ['get_data', 'change_attribute', 'log', 'store', 'close']},
     '__main__.Container': {'attributes': {'nested': 'Nested'},
      'methods': ['print_nested', 'log', 'store', 'close']},
     '__main__.UseNested': {'attributes': {},
      'methods': ['print_nested', 'log', 'store', 'close']},
     '__main__.ConfigVariableSample': {'attributes': {},
      'methods': ['print_configuration_variable', 'log', 'store', 'close']},
     '__main__.KeepLog': {'attributes': {'some_message': 'str'},
      'methods': ['log_it', 'log', 'store', 'close']},
     '__main__.KeepLog2': {'attributes': {'some_message2': 'str'},
      'methods': ['log_it', 'log', 'store', 'close']},
     '__main__.KeepResultsStored': {'attributes': {},
      'methods': ['store_results', 'log', 'store', 'close']},
     '__main__.KeepResultsStored2': {'attributes': {},
      'methods': ['store_results', 'log', 'store', 'close']}}




```python
# Lets close the pipeline and export the results.
krs2.close()

# Lets inspect the exported results.
def inspect_json(path):
    import json
    with open(path, 'r') as f:
        print(f"\nContents of '{path}':\n")
        print(json.dumps(json.load(f), indent=4))

inspect_json('dataclasses.json')
inspect_json('log.json')
inspect_json('store.json')
```

    
    Contents of 'dataclasses.json':
    
    {
        "__main__.DerivedClass": {
            "attributes": {
                "number": "int"
            },
            "methods": [
                "do",
                "log",
                "store",
                "close"
            ]
        },
        "__main__.DynamicAttribute": {
            "attributes": {
                "n": "int"
            },
            "methods": [
                "set_dynamically",
                "get_data",
                "log",
                "store",
                "close"
            ]
        },
        "__main__.DataClassSample": {
            "attributes": {
                "m": "int"
            },
            "methods": [
                "log",
                "store",
                "close"
            ]
        },
        "__main__.RetrieveSharedData": {
            "attributes": {},
            "methods": [
                "get_data",
                "change_attribute",
                "log",
                "store",
                "close"
            ]
        },
        "__main__.Container": {
            "attributes": {
                "nested": "Nested"
            },
            "methods": [
                "print_nested",
                "log",
                "store",
                "close"
            ]
        },
        "__main__.UseNested": {
            "attributes": {},
            "methods": [
                "print_nested",
                "log",
                "store",
                "close"
            ]
        },
        "__main__.ConfigVariableSample": {
            "attributes": {},
            "methods": [
                "print_configuration_variable",
                "log",
                "store",
                "close"
            ]
        },
        "__main__.KeepLog": {
            "attributes": {
                "some_message": "str"
            },
            "methods": [
                "log_it",
                "log",
                "store",
                "close"
            ]
        },
        "__main__.KeepLog2": {
            "attributes": {
                "some_message2": "str"
            },
            "methods": [
                "log_it",
                "log",
                "store",
                "close"
            ]
        },
        "__main__.KeepResultsStored": {
            "attributes": {},
            "methods": [
                "store_results",
                "log",
                "store",
                "close"
            ]
        },
        "__main__.KeepResultsStored2": {
            "attributes": {},
            "methods": [
                "store_results",
                "log",
                "store",
                "close"
            ]
        }
    }
    
    Contents of 'log.json':
    
    {
        "2023-11-16 18:43:24.020779": "I am a log message.",
        "2023-11-16 18:43:24.020933": "If you don't want it to be printed, set 'stdout' to 'False'.",
        "2023-11-16 18:43:24.021039": "I am a log message again.",
        "2023-11-16 18:43:24.021051": "My pipeline did something."
    }
    
    Contents of 'store.json':
    
    {
        "some_results": {
            "result": 3,
            "diff": 4
        },
        "some_results2": {
            "result2": 3,
            "diff2": 4
        }
    }

